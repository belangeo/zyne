# encoding: utf-8
""" 
---- Sections ----

1. Sections
2. Introduction
3. API
4. Basics
5. Reserved variables
6. Examples
7. Generic class to use as a startup

---- Introduction ----

What must be defined to include custom modules in the zyne framework ?

- In a python file:
    1 - Classes implementing custom dsp chains.
    2 - A dictionary, called `MODULES`, specifying the modules and their properties.
- In the preferences panel:
    3 - The path to your python file. Several modules can be defined in the file.


---- API ----

class BaseSynth(self, config, mode=1)

Parameters :
    config : dict
        This is the user-defined configuration dictionnary automatically sent by the application
        to the module in order to properly initialize the module. It must be pass directly from
        the module's __init__ method to the BaseSynth's __init__ method.
    mode : int {1, 2, 3}
        mode=1 means that the pitch from the keyboard is directly converted in Hertz.
        mode=2 means that the pitch from the keyboard is converted into transposition factor 
        with the C at pitch 60 is 1.0, eg. no transposition.
        mode=3 means that the pitch from the keyboard keeps its Midi note value.
        The keyboard can be transposed in semitones before the conversion in Hertz. This is 
        automatically done when a slider is defined with the param_name "Transposition".

Attributes :
    self.pitch : this variable contains frequencies, in Hertz, Midi notes or transposition factors, 
                from the pitches played on keyboard.
    self.amp : this variable contains the ADSR amplitude envelope, normalized between 0 and 1, derived
                from the velocities played on the keyboard.
    self.trig : this variable contains trigger streams generated by the noteon played on the keyboard.
                Useful to trig an envelope or a sound at the beginning of a note.


MODULES = {module_name : {  "title" : title_to_be_displayed,
                            "synth" : ref_to_custom_class,
                            "p1" : [param_name, init, min, max, is_integer, is_log],
                            "p2" : [param_name, init, min, max, is_integer, is_log],
                            "p3" : [param_name, init, min, max, is_integer, is_log]
                          },
          }

All custom modules properties are defined in a dictionary of dictionaries called "MODULES", one 
dictionary per module.

Syntax:
    module_name : str
        Reference name of the module, as it will appear in the Modules menu. Value for this key
        is the property's dictionary of the module.
    title_to_be_displayed : str
        String that will appear at the top of the module panel.
    ref_to_custom_class : class derived from BaseSynth
        Reference to the class implementing your dsp chain.
    param_name : str
        Label of the slider for the parameter. If a slider is defined with the param_name 
        "Transposition", this slider will be automatically used to transpose the note before
        the conversion in Hertz. The slider's properties (init, min, max, is_int) must be integer.
    init : int or float
        Initial value of the slider.
    min : int or float
        Minimum value of the slider.
    max : int or float
        Maximum value of the slider.
    is_integer : boolean
        Set this value to True to create a slider of integers, 
        False to create a slider of floating-points.
    is_log : boolean
        Set this value to True to create a logarithmic slider (`min` must be non-zero), 
        False to create a linear slider.


---- Basics ----

Every module must be derived from the class "BaseSynth" (you don't need to import specific modules
since your file will be executed in the proper environment).

The "BaseSynth" class is where are handled "pitch", "amplitude", "polyphony" and samples exportation.

Initialisation of the class BaseSynth:

BaseSynth.__init__(self, config, mode)

So your custom class should be defined like this:

class MySound(BaseSynth):
    def __init__(self, config):
        BaseSynth.__init__(self, config, mode=1)


---- Reserved variables ----

self.pitch : this variable contains frequencies, in Hertz, Midi notes or transposition factors, 
            from the pitches played on keyboard.
self.amp : this variable contains the ADSR amplitude envelope, normalized between 0 and 1, derived
            from the velocities played on the keyboard.
self.trig : this variable contains trigger streams generated by the noteon played on the keyboard.
            Useful to trig an envelope or a sound at the beginning of a note.
self.p1, self.p2, self.p3 : user-defined slider's values. These must be assigned to SigTo or Sig
            (if portamento is not desired) objects. To retrieve portamento time specified in
            the preferences panel, use vars.vars["SLIDERPORT"] for the `time` argument.
self.out : This variable must be the object that send the sound to the output. Although it is 
            possible, the custom class should not called the `out` method of any object. Every signals
            must be mixed in the self.out variable, which will then be sent to the post-processing
            module and finally to the soundcard.

To minimise conflicts between variable's names, all other variables used in the class "BaseSynth" 
begin with an underscore. If you don't use this syntax in your custom classes, you will avoid to
override basic module's objects.


---- Examples ----

Example of a simple module implementing a chorus of sine waves using semitone transposition:

class ChoruSyn(BaseSynth):
    def __init__(self, config):
        BaseSynth.__init__(self, config, mode=1)
        # First slider is used as semitone transpo, so nothing to define for self.p1
        # self.p2 = "Deviation speed"
        # self.p3 = "Deviation range"
        # 6 interpolated randoms
        self.pitchVar = Randi(min=0.-self.p3, max=self.p3, 
                              freq=self.p2*[random.uniform(.95, 1.05) for i in range(6)], add=1)
        # 6 oscillators (separated to properly handle keyboard polyphony)
        self.osc1 = Sine(freq=self.pitch*self.pitchVar[0], mul=self.amp*.1).mix(1)
        self.osc2 = Sine(freq=self.pitch*self.pitchVar[1], mul=self.amp*.1).mix(1)
        self.osc3 = Sine(freq=self.pitch*self.pitchVar[2], mul=self.amp*.1).mix(1)
        self.osc4 = Sine(freq=self.pitch*self.pitchVar[3], mul=self.amp*.1).mix(1)
        self.osc5 = Sine(freq=self.pitch*self.pitchVar[4], mul=self.amp*.1).mix(1)
        self.osc6 = Sine(freq=self.pitch*self.pitchVar[5], mul=self.amp*.1).mix(1)
        # stereo mix of all oscillators
        self.out = Mix([self.osc1, self.osc2, self.osc3, self.osc4, self.osc5, self.osc6], voices=2).out()

MODULES = {
            "ChoruSyn": { "title": "--- Chorused sines ---", "synth": ChoruSyn, 
                    "p1": ["Transposition", 0, -36, 36, True, False],
                    "p2": ["Deviation speed", 1, .1, 10, False, False],
                    "p3": ["Deviation range", 0.02, 0.001, .5, False, True]
                    },
          }

"""
import random, os
import Resources.variables as vars

if vars.vars["PYO_PRECISION"] == "single":
    from pyo import *
else:
    from pyo64 import *

def get_output_devices():
    return pa_get_output_devices()
def get_default_output():
    return pa_get_default_output()
def get_midi_input_devices():
    return pm_get_input_devices()
def get_midi_default_input():
    return pm_get_default_input()

class FSServer:
    def __init__(self):
        self.eqOn = False
        self.compOn = False
        self.eqFreq = [100, 500, 2000]
        self.eqGain = [1, 1, 1, 1]
        self.server = Server(audio=vars.vars["AUDIO_HOST"].lower())
        self.boot()
    
    def start(self):
        self.server.start()
    
    def stop(self):
        self.server.stop()
    
    def shutdown(self):
        self.server.shutdown()
    
    def boot(self):
        self.server.boot()
        self._outSig = Sig([0,0]).out()
        self._outSigMix = self._outSig.mix(1)
        
        self._fbEqAmps = SigTo(self.eqGain, time=.1, init=self.eqGain)
        self._fbEq = FourBand(self._outSig, freq1=self.eqFreq[0], 
                            freq2=self.eqFreq[1], freq3=self.eqFreq[2], mul=self._fbEqAmps).stop()
        self._outEq = Mix(self._fbEq, voices=2).stop()
        self._outEqMix = self._outEq.mix(1)
        
        self._compLevel = Compress(self._outSigMix, thresh=-3, ratio=2, risetime=.01, 
                                    falltime=.1, lookahead=0, knee=0.5, outputAmp=True).stop()
        self._compDelay = Delay(self._outSig, delay=0.005).stop()
        self._outComp = self._compDelay * self._compLevel
        self._outComp.stop()
    
    def reinit(self, audio):
        self.server.reinit(audio=audio.lower())
    
    def setAmpCallable(self, callable):
        self.server._server.setAmpCallable(callable)
    
    def recstart(self):
        self.server.recstart()
    
    def recstop(self):
        self.server.recstop()
    
    def setAmp(self, amp):
        self.server.amp = amp
    
    def setOutputDevice(self, device):
        if vars.vars["AUDIO_HOST"] != "Jack":
            self.server.setInOutDevice(device)
    
    def setMidiInputDevice(self, device):
        self.server.setMidiInputDevice(device)
    
    def setSamplingRate(self, sr):
        self.server.setSamplingRate(sr)
    
    def recordOptions(self, dur, filename, fileformat, sampletype):
        self.server.recordOptions(dur=dur, filename=filename, fileformat=fileformat, sampletype=sampletype)
    
    def onOffEq(self, state):
        if state == 1:
            self.eqOn = True
            self._outSig.play()
            self._fbEq.play()
            if not self.compOn:
                self._outEq.out()
            else:
                self._outEq.play()
                self._compLevel.input = self._outEqMix
                self._compDelay.input = self._outEq
        else:
            self.eqOn = False
            self._fbEq.stop()
            self._outEq.stop()
            if self.compOn:
                self._compLevel.input = self._outSigMix
                self._compDelay.input = self._outSig
                self._outComp.out()
            else:
                self._outSig.out()
    
    def setEqFreq(self, which, freq):
        self.eqFreq[which] = freq
        if which == 0:
            self._fbEq.freq1 = freq
        elif which == 1:
            self._fbEq.freq2 = freq
        elif which == 2:
            self._fbEq.freq3 = freq
    
    def setEqGain(self, which, gain):
        self.eqGain[which] = gain
        self._fbEqAmps.value = self.eqGain
    
    def onOffComp(self, state):
        if state == 1:
            self.compOn = True
            self._outSig.play()
            if self.eqOn:
                self._outEq.play()
                self._compLevel.input = self._outEqMix
                self._compDelay.input = self._outEq
            else:
                self._compLevel.input = self._outSigMix
                self._compDelay.input = self._outSig
            self._compLevel.play()
            self._compDelay.play()
            self._outComp.out()
        else:
            self.compOn = False
            self._compLevel.stop()
            self._compDelay.stop()
            self._outComp.stop()
            if self.eqOn:
                self._outEq.out()
            else:
                self._outSig.out()
    
    def setCompParam(self, param, value):
        if param == "thresh":
            self._compLevel.thresh = value
        elif param == "ratio":
            self._compLevel.ratio = value
        elif param == "risetime":
            self._compLevel.risetime = value
        elif param == "falltime":
            self._compLevel.falltime = value

class LFOSynth:
    def __init__(self, rng, trigger, lfo_config=None):
        #print lfo_config
        self.trigger = trigger
        self.rawamp = SigTo(.1, vars.vars["SLIDERPORT"], .1, mul=rng)
        self.amp = MidiAdsr(self.trigger, attack=5, decay=.1, sustain=.5, release=1, mul=self.rawamp)
        self.speed = SigTo(4, vars.vars["SLIDERPORT"], 4)
        self.jitter = SigTo(0, vars.vars["SLIDERPORT"], 0)
        self.freq = Randi(min=1-self.jitter, max=1+self.jitter, freq=1, mul=self.speed)
        self.lfo = LFO(freq=self.freq, sharp=.9, type=3, mul=self.amp).stop()
    
    def play(self):
        self.rawamp.play()
        self.amp.play()
        self.speed.play()
        self.jitter.play()
        self.freq.play()
        self.lfo.play()
    
    def stop(self):
        self.rawamp.stop()
        self.amp.stop()
        self.speed.stop()
        self.jitter.stop()
        self.freq.stop()
        self.lfo.stop()
    
    def sig(self):
        return self.lfo
    
    def setSpeed(self, x):
        self.speed.value = x
    
    def setType(self, x):
        self.lfo.type = x
    
    def setJitter(self, x):
        self.jitter.value = x
    
    def setAmp(self, x):
        self.rawamp.value = x
    
    def __del__(self):
        for key in self.__dict__.keys():
            del self.__dict__[key]

class Param:
    def __init__(self, parent, i, conf, lfo_trigger):
        self.parent = parent
        init = conf[1]
        mini = conf[2]
        maxi = conf[3]
        is_int = conf[4]
        rng = (maxi - mini)
        if is_int:
            self.slider = Sig(init)
            setattr(self.parent, "p%d" % (i+1), self.slider)
        else:
            self.lfo = LFOSynth(rng, lfo_trigger)
            self.slider = SigTo(init, vars.vars["SLIDERPORT"], init, add=self.lfo.sig())
            self.out = Clip(self.slider, mini, maxi)
            setattr(self.parent, "p%d" % (i+1), self.out)
    
    def set(self, x):
        self.slider.value = x
    
    def start_lfo(self, x):
        if x == 0:
            self.lfo.stop()
        else:
            self.lfo.play()

class BaseSynth:
    def __init__(self, config,  mode=1):
        if mode == 1:
            for conf in config:
                if conf[0] == "Transposition":
                    mode = 0
                    break
        if vars.vars["MIDIPITCH"] != None:
            if mode == 0:
                self._note = Sig(vars.vars["MIDIPITCH"])
                self.transpo = Sig(value=0)
                self.pitch = Snap(self._note+self.transpo, choice=[0,1,2,3,4,5,6,7,8,9,10,11], scale=1)
            elif mode == 1:
                self.pitch = Sig(midiToHz(vars.vars["MIDIPITCH"]))
            elif mode == 2:
                self.pitch = Sig(midiToTranspo(vars.vars["MIDIPITCH"]))
            elif mode == 3:
                self.pitch = Sig(vars.vars["MIDIPITCH"])
            self._firsttrig = Trig().play()
            self._secondtrig = Trig().play(delay=vars.vars["NOTEONDUR"])
            self._trigamp = Counter(Mix([self._firsttrig,self._secondtrig]), min=0, max=2, dir=1)
            self._lfo_amp = LFOSynth(.5, self._trigamp)
            self.amp = MidiAdsr(self._trigamp, attack=.001, decay=.1, sustain=.5, release=1, add=self._lfo_amp.sig())
            self.trig = Trig().play()
        elif vars.vars["VIRTUAL"]:
            self._virtualpit = Sig([0.0]*vars.vars["POLY"])
            self._trigamp = Sig([0.0]*vars.vars["POLY"])
            if mode == 0:
                self.transpo = Sig(value=0)
                self.pitch = Snap(self._virtualpit+self.transpo, choice=[0,1,2,3,4,5,6,7,8,9,10,11], scale=1)
            else:
                scaling = {1: 1, 2: 2, 3: 0}[mode]
                self.pitch = Snap(self._virtualpit, choice=[0,1,2,3,4,5,6,7,8,9,10,11], scale=scaling)
            self._lfo_amp = LFOSynth(.5, self._trigamp)
            self.amp = MidiAdsr(self._trigamp, attack=.001, decay=.1, sustain=.5, release=1, add=self._lfo_amp.sig())
            self.trig = Thresh(self._trigamp)
        else:
            if mode == 0:
                self._note = Notein(poly=vars.vars["POLY"], scale=0)
                self.transpo = Sig(value=0)
                self.pitch = Snap(self._note["pitch"]+self.transpo, choice=[0,1,2,3,4,5,6,7,8,9,10,11], scale=1)
            else:
                scaling = {1: 1, 2: 2, 3: 0}[mode]
                self._note = Notein(poly=vars.vars["POLY"], scale=scaling)
                self.pitch = self._note["pitch"]
            self._trigamp = self._note["velocity"]
            self._lfo_amp = LFOSynth(.5, self._trigamp)
            self.amp = MidiAdsr(self._trigamp, attack=.001, decay=.1, sustain=.5, release=1, add=self._lfo_amp.sig())
            self.trig = Thresh(self._trigamp)
    
        self.params = [None, None, None, self._lfo_amp]
        for i, conf in enumerate(config):
            init = conf[1]
            is_int = conf[4]
            if conf[0] != "Transposition":
                self.params[i] = Param(self, i, conf, self._trigamp)
    
    def set(self, which, x):
        self.params[which].set(x)
    
    def __del__(self):
        for key in self.__dict__.keys():
            del self.__dict__[key]

class FmSynth(BaseSynth):
    def __init__(self, config):
        BaseSynth.__init__(self, config,  mode=1)
        self.indexLine = self.amp * self.p2
        self.indexrnd = Randi(min=.95, max=1.05, freq=[random.uniform(.5,2) for i in range(4)])
        self.norm_amp = self.amp * 0.1
        self.fm1 = FM(carrier=self.pitch, ratio=self.p1, index=self.indexLine*self.indexrnd[0], mul=self.norm_amp)
        self.fm2 = FM(carrier=self.pitch*.997, ratio=self.p1, index=self.indexLine*self.indexrnd[1], mul=self.norm_amp)
        self.fm3 = FM(carrier=self.pitch*.995, ratio=self.p1, index=self.indexLine*self.indexrnd[2], mul=self.norm_amp)
        self.fm4 = FM(carrier=self.pitch*1.002, ratio=self.p1, index=self.indexLine*self.indexrnd[3], mul=self.norm_amp)
        self.mix = Mix([self.fm1.mix(), self.fm2.mix(), self.fm3.mix(), self.fm4.mix()], voices=2)
        self.out = Biquadx(self.mix, freq=self.p3, q=1, type=0, stages=2)

class AddSynth(BaseSynth):
    def __init__(self, config):
        BaseSynth.__init__(self, config, mode=1)
        self.fac = Pow(range(1,6), self.p2, mul=[random.uniform(.995,1.005) for i in range(4)])
        self.feedrnd = Randi(min=.15, max=.25, freq=[random.uniform(.5,2) for i in range(4)])
        self.norm_amp = self.amp * 0.1
        self.sine1 = SineLoop(freq=self.pitch*self.fac[0], feedback=self.p3*self.feedrnd[0], mul=self.norm_amp).mix()
        self.sine2 = SineLoop(freq=self.pitch*self.fac[1], feedback=self.p3*self.feedrnd[1], mul=self.norm_amp).mix()
        self.sine3 = SineLoop(freq=self.pitch*self.fac[2], feedback=self.p3*self.feedrnd[2], mul=self.norm_amp).mix()
        self.sine4 = SineLoop(freq=self.pitch*self.fac[3], feedback=self.p3*self.feedrnd[3], mul=self.norm_amp).mix()
        self.out = Mix([self.sine1+self.sine2+self.sine3+self.sine4], voices=2)

class PhaserSynth(BaseSynth):
    def __init__(self, config):
        BaseSynth.__init__(self, config, mode=1)
        self.pit = Sig(self.pitch, mul=.125)
        self.clpit = Clip(self.pit, min=1, max=18000)
        self.noise = Noise(mul=self.amp*.01)
        self.phaser = Phaser(self.noise, self.clpit, self.p1, self.p2, self.p3, num=4, mul=self.amp).mix()
        self.out = self.phaser.mix(2)

class SquareMod(BaseSynth):
    def __init__(self, config):
        BaseSynth.__init__(self, config, mode=1)
        self.table = SquareTable(order=10, size=2048)
        self.change = Change(self.p1)
        self.trigChange = TrigFunc(self.change, function=self.changeOrder)
        self.lfo = Osc(table=self.table, freq=self.p2, mul=self.p3*.1, add=.1)
        self.norm_amp = self.amp * self.lfo
        self.osc1 = Osc(table=self.table, freq=self.pitch, mul=self.norm_amp).mix()
        self.osc2 = Osc(table=self.table, freq=self.pitch*.994, mul=self.norm_amp).mix()
        self.osc3 = Osc(table=self.table, freq=self.pitch*.998, mul=self.norm_amp).mix()
        self.osc4 = Osc(table=self.table, freq=self.pitch*1.003, mul=self.norm_amp).mix()
        self.out = Mix([self.osc1, self.osc2, self.osc3, self.osc4], voices=2)
    
    def changeOrder(self):
        order = int(self.p1.get())
        self.table.order = order

class SawMod(BaseSynth):
    def __init__(self, config):
        BaseSynth.__init__(self, config, mode=1)
        self.table = SawTable(order=10, size=2048)
        self.change = Change(self.p1)
        self.trigChange = TrigFunc(self.change, function=self.changeOrder)
        self.lfo = Osc(table=self.table, freq=self.p2, mul=self.p3*.0707, add=.0707)
        self.norm_amp = self.amp * self.lfo
        self.osc1 = Osc(table=self.table, freq=self.pitch, mul=self.norm_amp).mix()
        self.osc2 = Osc(table=self.table, freq=self.pitch*.995, mul=self.norm_amp).mix()
        self.osc3 = Osc(table=self.table, freq=self.pitch*.998, mul=self.norm_amp).mix()
        self.osc4 = Osc(table=self.table, freq=self.pitch*1.004, mul=self.norm_amp).mix()
        self.out = Mix([self.osc1, self.osc2, self.osc3, self.osc4], voices=2)
    
    def changeOrder(self):
        order = int(self.p1.get())
        self.table.order = order

class PulsarSynth(BaseSynth):
    def __init__(self, config):
        BaseSynth.__init__(self, config, mode=1)
        self.table = SawTable(order=10, size=2048)
        self.change = Change(self.p1)
        self.trigChange = TrigFunc(self.change, function=self.changeOrder)
        self.env = HannTable()
        self.lfo = Sine(freq=self.p3, mul=.25, add=.7)
        self.norm_amp = self.amp * 0.2
        self.pulse1 = Pulsar(table=self.table, env=self.env, freq=self.pitch, frac=self.lfo, mul=self.norm_amp).mix()
        self.pulse2 = Pulsar(table=self.table, env=self.env, freq=self.pitch*.998, frac=self.lfo, mul=self.norm_amp).mix()
        self.pulse3 = Pulsar(table=self.table, env=self.env, freq=self.pitch*.997, frac=self.lfo, mul=self.norm_amp).mix()
        self.pulse4 = Pulsar(table=self.table, env=self.env, freq=self.pitch*1.002, frac=self.lfo, mul=self.norm_amp).mix()
        self.out = Mix([self.pulse1, self.pulse2, self.pulse3, self.pulse4], voices=2)
    
    def changeOrder(self):
        order = int(self.p1.get())
        self.table.order = order

class Ross(BaseSynth):
    def __init__(self, config):
        BaseSynth.__init__(self, config, mode=1)
        self.rosspit = Clip(self.pitch / 5000. + 0.25, min=0., max=1.)
        self.deviation = Randi(min=0.-self.p2, max=self.p2, freq=[random.uniform(2,4) for i in range(2)], add=1)
        self.norm_amp = self.amp * 0.3
        self.ross1 = Rossler(pitch=self.rosspit*self.deviation[0], chaos=self.p1, stereo=True, mul=self.norm_amp)
        self.ross2 = Rossler(pitch=self.rosspit*self.deviation[1], chaos=self.p1, stereo=True, mul=self.norm_amp)
        self.mix = Mix(self.ross1 + self.ross2, voices=2)
        self.eq = EQ(self.mix, freq=260, q=25, boost=-12)
        self.out = Biquad(self.eq, freq=self.p3)

class Wave(BaseSynth):
    def __init__(self, config):
        BaseSynth.__init__(self, config, mode=1)
        self.change = Change(self.p1)
        self.trigChange = TrigFunc(self.change, function=self.changeWave)
        self.norm_amp = self.amp * 0.15
        self.wav1 = LFO(freq=self.pitch, sharp=self.p3, type=0, mul=self.norm_amp)
        self.wav2 = LFO(freq=self.pitch*.997, sharp=self.p3, type=0, mul=self.norm_amp)
        self.wav3 = LFO(freq=self.pitch*1.002, sharp=self.p3, type=0, mul=self.norm_amp)
        self.wav4 = LFO(freq=self.pitch*1.0045, sharp=self.p3, type=0, mul=self.norm_amp)
        self.out = Mix([self.wav1.mix(),self.wav2.mix(),self.wav3.mix(),self.wav4.mix()], voices=2)
    
    def changeWave(self):
        typ = int(self.p1.get())
        self.wav1.type = typ
        self.wav2.type = typ
        self.wav3.type = typ
        self.wav4.type = typ

class PluckedString(BaseSynth):
    def __init__(self, config):
        BaseSynth.__init__(self, config, mode=1)
        self.deviation = Randi(min=0.-self.p3, max=self.p3, freq=[random.uniform(2,4) for i in range(2)], add=1)
        self.table = CosTable([(0,0),(50,1),(300,0),(8191,0)])
        self.impulse = TrigEnv(self.trig, table=self.table, dur=.1)
        self.noise = Biquad(Noise(self.impulse), freq=2500)
        self.wave1 = Waveguide(self.noise, freq=self.pitch*self.deviation[0], dur=self.p2, minfreq=.5, mul=self.amp).mix()
        self.wave2 = Waveguide(self.noise, freq=self.pitch*self.deviation[1], dur=self.p2, minfreq=.5, mul=self.amp).mix()
        self.out = Mix([self.wave1, self.wave2], voices=2)

class Reson(BaseSynth):
    def __init__(self, config):
        BaseSynth.__init__(self, config, mode=1)
        self.deviation = Randi(min=0.-self.p2, max=self.p2, freq=[random.uniform(2,4) for i in range(4)], add=1)
        self.excite = Noise(.02)
        self.wave1 = Waveguide(self.excite, freq=self.pitch*self.deviation[0], dur=30, minfreq=1, mul=self.amp).mix()
        self.wave2 = Waveguide(self.excite, freq=self.pitch*self.deviation[1], dur=30, minfreq=1, mul=self.amp).mix()
        self.mix = Mix([self.wave1, self.wave2], voices=2)
        self.out = Biquad(self.mix, freq=self.p3)

def checkForCustomModules():
    path = ""
    preffile = os.path.join(os.path.expanduser("~"), ".zynerc")
    if os.path.isfile(preffile):
        with open(preffile, "r") as f:
            lines = f.readlines()
            if not lines[0].startswith("### Zyne") or not vars.constants["VERSION"] in lines[0]:
                pass
            else:
                for line in lines:
                    if "CUSTOM_MODULES_PATH" in line:
                        line = line.strip()
                        if line:
                            sline = line.split("=")
                            path = sline[1].strip()
    
    if path != "":
        if os.path.isfile(path):
            execfile(path, globals())
            vars.vars["EXTERNAL_MODULES"] = MODULES


checkForCustomModules()
