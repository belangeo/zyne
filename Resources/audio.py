# encoding: utf-8
""" 
---- Sections ----

1. Sections
2. Introduction
3. API
4. Basics
5. Reserved variables
6. Examples
7. Generic class to use as a startup

---- Introduction ----

What must be defined to include custom modules in the zyne application ?

- In a python file:
    1 - Classes implementing custom dsp chains.
    2 - A dictionary, called `MODULES`, specifying the modules and their properties.
- In the preferences panel:
    3 - The path to your python file. Several modules can be defined in the file.


---- API ----

class BaseSynth(self, config, mode=1)

Parameters :
    config : dict
        This is the user-defined configuration dictionnary automatically sent by the application
        to the module in order to properly initialize the module. It must be passed directly from
        the module's __init__ method to the BaseSynth's __init__ method.
    mode : int {1, 2, 3}, optional
        mode=1 (default) means that the pitches from the keyboard are directly converted in Hertz.
        mode=2 means that the pitches from the keyboard are converted into transposition factor 
        with the Midi key 60 as 1.0, eg. no transposition.
        mode=3 means that the pitches from the keyboard keep their Midi note value.
        
        The keyboard can be transposed in semitones before the midi-to-hertz or the
        midi-to-transpo conversion. This is automatically done when a slider is 
        defined with "Transposition" as the param_name.

Attributes :
    self.pitch : This variable contains frequencies, in Hertz, Midi notes or transposition factors, 
                from the pitches played on keyboard.
    self.amp : This variable contains the ADSR amplitude envelope, normalized between 0 and 1, derived
                from the velocities played on the keyboard.
    self.panL, self.panR : These variables contains panning values for left and right channels. The user
                has to multiply his left and right signals with these variables in order to use the "Pan" slider.
    self.trig : This variable contains trigger streams generated by the noteon played on the keyboard.
                Useful to trig an envelope or a sound at the beginning of a note.
    self.p1, self.p2, self.p3 : User-defined slider's values.


MODULES = {module_name : {  "title" : title_to_be_displayed,
                            "synth" : ref_to_custom_class,
                            "p1" : [param_name, init, min, max, is_integer, is_log],
                            "p2" : [param_name, init, min, max, is_integer, is_log],
                            "p3" : [param_name, init, min, max, is_integer, is_log]
                          },
          }

All custom module's properties are defined in a dictionary of dictionaries called "MODULES", one 
dictionary per module.

Syntax:
    module_name : str
        Reference name of the module, as it will appear in the Modules menu. Value for this key
        is the dictionary of properties for the module.
    title_to_be_displayed : str
        String that will appear at the top of the module panel.
    ref_to_custom_class : class derived from BaseSynth
        Reference to the class implementing the dsp chain.
    param_name : str
        Label of the slider for the parameter. If "Transposition" is used as the param_name, the 
        slider will be automatically used to transpose the note before the the midi-to-hertz or the 
        midi-to-transpo conversion. The slider's properties (init, min, max, is_int) must be integer.
    init : int or float
        Initial value of the slider.
    min : int or float
        Minimum value of the slider.
    max : int or float
        Maximum value of the slider.
    is_integer : boolean
        Set this value to True to create a slider of integers or False to create a slider of floats.
    is_log : boolean
        Set this value to True to create a logarithmic slider (`min` must be non-zero) or False to 
        create a linear slider.


---- Basics ----

Each module must be derived from the class "BaseSynth" (you don't need to import specific modules
since your file will be executed in the proper environment).

The "BaseSynth" class is where are handled "pitch", "amplitude", "polyphony", user-defined attributes
(p1, p2, p3) and samples exportation.

Initialisation of the class BaseSynth:

BaseSynth.__init__(self, config, mode)

So your custom class should be defined like this:

class MySound(BaseSynth):
    def __init__(self, config):
        BaseSynth.__init__(self, config, mode=1)


---- Reserved variables ----

self.pitch : this variable contains frequencies, in Hertz, Midi notes or transposition factors, 
            from the pitches played on keyboard.
self.amp : this variable contains the ADSR amplitude envelope, normalized between 0 and 1, derived
            from the velocities played on the keyboard.
self.panL, self.panR : These variables contains panning values for left and right channels. The user
            has to multiply his left and right signals with these variables in order to use the "Pan" slider.
self.trig : this variable contains trigger streams generated by the noteon played on the keyboard.
            Useful to trig an envelope or a sound at the beginning of the note.
self.p1, self.p2, self.p3 : user-defined slider's values.
self.out : This variable must be the object that send the sound to the output. Although it is 
            possible, the custom class should not called the `out` method of any object. Every signals
            must be mixed in the self.out variable, which will then be sent to the post-processing
            effects and finally to the soundcard.

To minimise conflicts between variable's names, all other variables used in the class "BaseSynth" 
begin with an underscore. If you don't use this syntax in your custom classes, you will avoid to
override basic module's objects.


---- Examples ----

Example of a file containing two modules. First, a simple module implementing a chorus of sine waves 
using semitone transposition and second, a soundfile looper/slicer using transposition factor derived 
from the keyboard's pitches.

class ChoruSyn(BaseSynth):
    def __init__(self, config):
        BaseSynth.__init__(self, config, mode=1)
        # First slider is used as semitone transpo, so self.p1 is not defined
        # self.p2 = "Deviation speed"
        # self.p3 = "Deviation range"
        # 6 interpolated randoms
        self.pitchVar = Randi(min=0.-self.p3, max=self.p3, 
                              freq=self.p2*[random.uniform(.95, 1.05) for i in range(6)], add=1)
        # 6 oscillators (separated to properly handle keyboard polyphony)
        self.norm_amp = self.amp * .1
        self.leftamp = self.norm_amp*self.panL
        self.rightamp = self.norm_amp*self.panR
        self.osc1 = Sine(freq=self.pitch*self.pitchVar[0], mul=self.leftamp).mix(1)
        self.osc2 = Sine(freq=self.pitch*self.pitchVar[1], mul=self.rightamp).mix(1)
        self.osc3 = Sine(freq=self.pitch*self.pitchVar[2], mul=self.leftamp).mix(1)
        self.osc4 = Sine(freq=self.pitch*self.pitchVar[3], mul=self.rightamp).mix(1)
        self.osc5 = Sine(freq=self.pitch*self.pitchVar[4], mul=self.leftamp).mix(1)
        self.osc6 = Sine(freq=self.pitch*self.pitchVar[5], mul=self.rightamp).mix(1)
        # stereo mix of all oscillators
        self.out = Mix([self.osc1, self.osc2, self.osc3, self.osc4, self.osc5, self.osc6], voices=2).out()

class SndLooper(BaseSynth):
    def __init__(self, config):
        BaseSynth.__init__(self, config, mode=2)
        self.table = SndTable(SNDS_PATH+"/transparent.aif")
        self.st = Phasor(.1, mul=self.table.getDur()-.25)
        self.dur = Choice([.125, .125, .125, .25, .25, .5], freq=1)
        self.varFreq = self.p2*[random.uniform(.95, 1.05) for i in range(2)]
        self.pitchVar = Randi(min=0.-self.p3, max=self.p3, freq=self.varFreq, add=1)
        self.looper1 = Looper(self.table, pitch=self.pitch, start=self.st*self.pitchVar[0], 
                          dur=self.dur, interp=4, autosmooth=True, mul=self.amp*self.panL).mix(1)
        self.looper2 = Looper(self.table, pitch=self.pitch, start=self.st*self.pitchVar[1], 
                          dur=self.dur, interp=4, autosmooth=True, mul=self.amp*self.panR).mix(1)
        self.out = Mix([self.looper1, self.looper2], voices=2)

MODULES = {
            "ChoruSyn": { "title": "--- Chorused sines ---", "synth": ChoruSyn, 
                    "p1": ["Transposition", 0, -36, 36, True, False],
                    "p2": ["Deviation speed", 1, .1, 10, False, False],
                    "p3": ["Deviation range", 0.02, 0.001, .5, False, True]
                    },
            "SndLooper": { "title": "--- Sound Looper ---", "synth": SndLooper, 
                    "p1": ["Transposition", 0, -36, 36, True, False],
                    "p2": ["Deviation speed", 1, .1, 10, False, False],
                    "p3": ["Deviation range", 0.02, 0.001, .5, False, True]
                    },
          }


---- Generic class to use as a startup ----

class GenericModule(BaseSynth):
    def __init__(self, config):
        # `mode` handles pitch conversion : 1 for hertz, 2 for transpo, 3 for midi
        BaseSynth.__init__(self, config, mode=1)
        self.fm1 = FM(carrier=self.pitch, ratio=self.p1, index=self.p2, mul=self.amp*self.leftamp).mix(1)
        self.fm2 = FM(carrier=self.pitch*0.997, ratio=self.p1, index=self.p2, mul=self.amp*self.rightamp).mix(1)
        self.mix = Mix([self.fm1, self.fm2], voices=2)
        self.out = Biquad(self.mix, freq=self.p3, q=1, type=0)

MODULES = {
            "GenericModule": { "title": "--- Generic module ---", "synth": GenericModule, 
                    "p1": ["Ratio", 0.5, 0, 10, False, False],
                    "p2": ["Index", 5, 0, 20, False, False],
                    "p3": ["LP cutoff", 4000, 100, 15000, False, True]
                    },
          }

"""
import random, os, time, math, codecs
import Resources.variables as vars
from types import ListType

if vars.vars["PYO_PRECISION"] == "single":
    from pyo import *
else:
    from pyo64 import *

def get_output_devices():
    return pa_get_output_devices()
def get_default_output():
    return pa_get_default_output()
def get_midi_input_devices():
    return pm_get_input_devices()
def get_midi_default_input():
    return pm_get_default_input()

class FSServer:
    def __init__(self):
        self.eqOn = False
        self.compOn = False
        self.eqFreq = [100, 500, 2000]
        self.eqGain = [1, 1, 1, 1]
        self.server = Server(audio=vars.vars["AUDIO_HOST"].lower())
        self.boot()
    
    def scanning(self, x):
        if vars.vars["LEARNINGSLIDER"] != None:
            vars.vars["LEARNINGSLIDER"].setMidiCtl(x)
            vars.vars["LEARNINGSLIDER"].Enable()
            vars.vars["LEARNINGSLIDER"] = None
    
    def startMidiLearn(self):
        self.server.shutdown()
        self.server.boot()
        self.scan = CtlScan(self.scanning, False)
        self.server.start()
    
    def stopMidiLearn(self):
        del self.scan
        self.server.stop()
        time.sleep(.25)
    
    def start(self):
        self.server.start()
    
    def stop(self):
        self.server.stop()
    
    def shutdown(self):
        self.server.shutdown()
    
    def boot(self):
        self.server.boot()
        self._outSig = Sig([0,0]).out()
        vars.vars["MIDI_ACTIVE"] = self.server.getMidiActive()
        #print "midi is active :", vars.vars["MIDI_ACTIVE"]
        self._outSigMix = self._outSig.mix(1)
        
        self._fbEqAmps = SigTo(self.eqGain, time=.1, init=self.eqGain)
        self._fbEq = FourBand(self._outSig, freq1=self.eqFreq[0], 
                            freq2=self.eqFreq[1], freq3=self.eqFreq[2], mul=self._fbEqAmps).stop()
        self._outEq = Mix(self._fbEq, voices=2).stop()
        self._outEqMix = self._outEq.mix(1)
        
        self._compLevel = Compress(self._outSigMix, thresh=-3, ratio=2, risetime=.01, 
                                    falltime=.1, lookahead=0, knee=0.5, outputAmp=True).stop()
        self._compDelay = Delay(self._outSig, delay=0.005).stop()
        self._outComp = self._compDelay * self._compLevel
        self._outComp.stop()
    
    def reinit(self, audio):
        self.server.reinit(audio=audio.lower())
    
    def setAmpCallable(self, callable):
        self.server._server.setAmpCallable(callable)
    
    def recstart(self):
        self.server.recstart()
    
    def recstop(self):
        self.server.recstop()
    
    def setAmp(self, amp):
        self.server.amp = amp
    
    def setOutputDevice(self, device):
        if vars.vars["AUDIO_HOST"] != "Jack":
            self.server.setInOutDevice(device)
    
    def setMidiInputDevice(self, device):
        self.server.setMidiInputDevice(device)
    
    def setSamplingRate(self, sr):
        self.server.setSamplingRate(sr)
    
    def recordOptions(self, dur, filename, fileformat, sampletype):
        self.server.recordOptions(dur=dur, filename=filename, fileformat=fileformat, sampletype=sampletype)
    
    def onOffEq(self, state):
        if state == 1:
            self.eqOn = True
            self._outSig.play()
            self._fbEq.play()
            if not self.compOn:
                self._outEq.out()
            else:
                self._outEq.play()
                self._compLevel.input = self._outEqMix
                self._compDelay.input = self._outEq
        else:
            self.eqOn = False
            self._fbEq.stop()
            self._outEq.stop()
            if self.compOn:
                self._compLevel.input = self._outSigMix
                self._compDelay.input = self._outSig
                self._outComp.out()
            else:
                self._outSig.out()
    
    def setEqFreq(self, which, freq):
        self.eqFreq[which] = freq
        if which == 0:
            self._fbEq.freq1 = freq
        elif which == 1:
            self._fbEq.freq2 = freq
        elif which == 2:
            self._fbEq.freq3 = freq
    
    def setEqGain(self, which, gain):
        self.eqGain[which] = gain
        self._fbEqAmps.value = self.eqGain
    
    def onOffComp(self, state):
        if state == 1:
            self.compOn = True
            self._outSig.play()
            if self.eqOn:
                self._outEq.play()
                self._compLevel.input = self._outEqMix
                self._compDelay.input = self._outEq
            else:
                self._compLevel.input = self._outSigMix
                self._compDelay.input = self._outSig
            self._compLevel.play()
            self._compDelay.play()
            self._outComp.out()
        else:
            self.compOn = False
            self._compLevel.stop()
            self._compDelay.stop()
            self._outComp.stop()
            if self.eqOn:
                self._outEq.out()
            else:
                self._outSig.out()
    
    def setCompParam(self, param, value):
        if param == "thresh":
            self._compLevel.thresh = value
        elif param == "ratio":
            self._compLevel.ratio = value
        elif param == "risetime":
            self._compLevel.risetime = value
        elif param == "falltime":
            self._compLevel.falltime = value

class CtlBind:
    def __init__(self):
        self.last_midi_val = 0.0
        self.lfo_last_midi_vals = [0.0, 0.0, 0.0, 0.0]
    
    def valToWidget(self):
        val = self.midictl.get()
        if val != self.last_midi_val:
            self.last_midi_val = val
            if self.widget.log:
                val **= 10.0
                val *= (self.widget.getMaxValue() - self.widget.getMinValue()) 
                val += self.widget.getMinValue()
            self.widget.setValue(val)
    
    def valToWidget0(self):
        val = self.lfo_midictl_0.get()
        is_log = self.lfo_widget_0.log
        if val != self.lfo_last_midi_vals[0]:
            self.lfo_last_midi_vals[0] = val
            if is_log:
                val **= 10.0
                val *= (self.lfo_widget_0.getMaxValue() - self.lfo_widget_0.getMinValue())
                val += self.lfo_widget_0.getMinValue()
            self.lfo_widget_0.setValue(val)
            self.lfo_widget_0.outFunction(val)
    
    def valToWidget1(self):
        val = self.lfo_midictl_1.get()
        is_log = self.lfo_widget_1.log
        if val != self.lfo_last_midi_vals[1]:
            self.lfo_last_midi_vals[1] = val
            if is_log:
                val **= 10.0
                val *= (self.lfo_widget_1.getMaxValue() - self.lfo_widget_1.getMinValue())
                val += self.lfo_widget_1.getMinValue()
            self.lfo_widget_1.setValue(val)
            self.lfo_widget_1.outFunction(val)
    
    def valToWidget2(self):
        val = self.lfo_midictl_2.get()
        is_log = self.lfo_widget_2.log
        if val != self.lfo_last_midi_vals[2]:
            self.lfo_last_midi_vals[2] = val
            if is_log:
                val **= 10.0
                val *= (self.lfo_widget_2.getMaxValue() - self.lfo_widget_2.getMinValue())
                val += self.lfo_widget_2.getMinValue()
            self.lfo_widget_2.setValue(val)
            self.lfo_widget_2.outFunction(val)
    
    def valToWidget3(self):
        val = self.lfo_midictl_3.get()
        is_log = self.lfo_widget_3.log
        if val != self.lfo_last_midi_vals[3]:
            self.lfo_last_midi_vals[3] = val
            if is_log:
                val **= 10.0
                val *= (self.lfo_widget_3.getMaxValue() - self.lfo_widget_3.getMinValue())
                val += self.lfo_widget_3.getMinValue()
            self.lfo_widget_3.setValue(val)
            self.lfo_widget_3.outFunction(val)
    
    def assignMidiCtl(self, ctl, widget):
        if not vars.vars["MIDI_ACTIVE"]:
            return
        mini = widget.getMinValue()
        maxi = widget.getMaxValue()
        value = widget.GetValue()
        is_log = widget.log
        self.widget = widget
        if is_log:
            norm_init = pow(float(value - mini) / (maxi - mini), .1)
            self.midictl = Midictl(ctl, 0, 1.01, norm_init)
        else:
            self.midictl = Midictl(ctl, mini, maxi+.1, value)
        self.trigFunc = TrigFunc(self._midi_metro, self.valToWidget)
    
    def assignLfoMidiCtl(self, ctl, widget, i):
        if not vars.vars["MIDI_ACTIVE"]:
            return
        mini = widget.getMinValue()
        maxi = widget.getMaxValue()
        value = widget.GetValue()
        is_log = widget.log
        if i == 0:
            self.lfo_widget_0 = widget
            if is_log:
                norm_init = pow(float(value - mini) / (maxi - mini), .1)
                self.lfo_midictl_0 = Midictl(ctl, 0, 1.01, norm_init)
            else:
                self.lfo_midictl_0 = Midictl(ctl, mini, maxi+.1, value)
            self.lfo_trigFunc_0 = TrigFunc(self._midi_metro, self.valToWidget0)
        elif i == 1:
            self.lfo_widget_1 = widget
            if is_log:
                norm_init = pow(float(value - mini) / (maxi - mini), .1)
                self.lfo_midictl_1 = Midictl(ctl, 0, 1.01, norm_init)
            else:
                self.lfo_midictl_1 = Midictl(ctl, mini, maxi+.1, value)
            self.lfo_trigFunc_1 = TrigFunc(self._midi_metro, self.valToWidget1)
        elif i == 2:
            self.lfo_widget_2 = widget
            if is_log:
                norm_init = pow(float(value - mini) / (maxi - mini), .1)
                self.lfo_midictl_2 = Midictl(ctl, 0, 1.01, norm_init)
            else:
                self.lfo_midictl_2 = Midictl(ctl, mini, maxi+.1, value)
            self.lfo_trigFunc_2 = TrigFunc(self._midi_metro, self.valToWidget2)
        elif i == 3:
            self.lfo_widget_3 = widget
            if is_log:
                norm_init = pow(float(value - mini) / (maxi - mini), .1)
                self.lfo_midictl_3 = Midictl(ctl, 0, 1.01, norm_init)
            else:
                self.lfo_midictl_3 = Midictl(ctl, mini, maxi+.1, value)
            self.lfo_trigFunc_3 = TrigFunc(self._midi_metro, self.valToWidget3)

class LFOSynth(CtlBind):
    def __init__(self, rng, trigger, midi_metro, lfo_config=None):
        CtlBind.__init__(self)
        self.trigger = trigger
        self._midi_metro = midi_metro
        self.rawamp = SigTo(.1, vars.vars["SLIDERPORT"], .1, mul=rng)
        self.amp = MidiDelAdsr(self.trigger, delay=0, attack=5, decay=.1, sustain=.5, release=1, mul=self.rawamp)
        self.speed = SigTo(4, vars.vars["SLIDERPORT"], 4)
        self.jitter = SigTo(0, vars.vars["SLIDERPORT"], 0)
        self.freq = Randi(min=1-self.jitter, max=1+self.jitter, freq=1, mul=self.speed)
        self.lfo = LFO(freq=self.freq, sharp=.9, type=3, mul=self.amp).stop()
    
    def play(self):
        self.rawamp.play()
        self.amp.play()
        self.speed.play()
        self.jitter.play()
        self.freq.play()
        self.lfo.play()
    
    def stop(self):
        self.rawamp.stop()
        self.amp.stop()
        self.speed.stop()
        self.jitter.stop()
        self.freq.stop()
        self.lfo.stop()
    
    def sig(self):
        return self.lfo
    
    def setSpeed(self, x):
        self.speed.value = x
    
    def setType(self, x):
        self.lfo.type = x
    
    def setJitter(self, x):
        self.jitter.value = x
    
    def setAmp(self, x):
        self.rawamp.value = x
    
    def __del__(self):
        for key in self.__dict__.keys():
            del self.__dict__[key]

class Param(CtlBind):
    def __init__(self, parent, i, conf, lfo_trigger, midi_metro):
        CtlBind.__init__(self)
        self.parent = parent
        self._midi_metro = midi_metro
        self.init, self.mini, self.maxi, self.is_int, self.is_log = conf[1], conf[2], conf[3], conf[4], conf[5]
        rng = (self.maxi - self.mini)
        if self.is_int:
            self.slider = Sig(self.init)
            setattr(self.parent, "p%d" % i, self.slider)
        else:
            self.lfo = LFOSynth(rng, lfo_trigger, midi_metro)
            self.slider = SigTo(self.init, vars.vars["SLIDERPORT"], self.init, add=self.lfo.sig())
            self.out = Clip(self.slider, self.mini, self.maxi)
            setattr(self.parent, "p%d" % i, self.out)
    
    def set(self, x):
        self.slider.value = x
    
    def start_lfo(self, x):
        if x == 0:
            self.lfo.stop()
        else:
            self.lfo.play()
    
    def __del__(self):
        for key in self.__dict__.keys():
            del self.__dict__[key]

class Panner(CtlBind):
    def __init__(self, parent, lfo_trigger, midi_metro):
        CtlBind.__init__(self)
        self.parent = parent
        self.lfo_trigger = Clip(lfo_trigger*100., 0, 1)
        self._midi_metro = midi_metro
        self.lfo = LFOSynth(0.5, self.lfo_trigger, midi_metro)
        self.slider = SigTo(0.5, vars.vars["SLIDERPORT"], 0.5, add=self.lfo.sig())
        self.clip = Clip(self.slider, 0., 1.)
        self.amp_L = Sqrt(1 - self.clip)
        self.amp_R = Sqrt(self.clip)

    def set(self, x):
        self.slider.value = x

    def start_lfo(self, x):
        if not x:
            self.lfo.stop()
        else:
            self.lfo.play()

    def __del__(self):
        for key in self.__dict__.keys():
            del self.__dict__[key]

class ParamTranspo:
    def __init__(self, parent, midi_metro):
        self.parent = parent
        self._midi_metro = midi_metro
        self.last_midi_val = 0.0
    
    def valToWidget(self):
        val = self.midictl.get()
        if val != self.last_midi_val:
            self.last_midi_val = val
            self.widget.setValue(val)
    
    def assignMidiCtl(self, ctl, widget):
        self.widget = widget
        self.midictl = Midictl(ctl, -36.5, 36.5, widget.GetValue())
        self.trigFunc = TrigFunc(self._midi_metro, self.valToWidget)
    
    def __del__(self):
        for key in self.__dict__.keys():
            del self.__dict__[key]

class BaseSynth:
    def __init__(self, config,  mode=1):
        scaling = {1: 1, 2: 2, 3: 0}[mode]
        with_transpo = False
        for conf in config:
            if conf[0] == "Transposition":
                with_transpo = True
                break
        self._midi_metro = Metro(.1).play()
        self._rawamp = SigTo(1, vars.vars["SLIDERPORT"], 1)
        if vars.vars["MIDIPITCH"] != None:
            if with_transpo:
                self._note = Sig(vars.vars["MIDIPITCH"])
                self._transpo = Sig(value=0)
                self.pitch = Snap(self._note+self._transpo, choice=[0,1,2,3,4,5,6,7,8,9,10,11], scale=scaling)
            elif mode == 1:
                if type(vars.vars["MIDIPITCH"]) == ListType:
                    _tmp_hz = [midiToHz(x) for x in vars.vars["MIDIPITCH"]]
                else:
                    _tmp_hz = midiToHz(vars.vars["MIDIPITCH"])
                self.pitch = Sig(_tmp_hz)
            elif mode == 2:
                if type(vars.vars["MIDIPITCH"]) == ListType:
                    _tmp_tr = [midiToTranspo(x) for x in vars.vars["MIDIPITCH"]]
                else:
                    _tmp_tr = midiToTranspo(vars.vars["MIDIPITCH"])
                self.pitch = Sig(_tmp_tr)
            elif mode == 3:
                self.pitch = Sig(vars.vars["MIDIPITCH"])
            self._firsttrig = Trig().play()
            self._secondtrig = Trig().play(delay=vars.vars["NOTEONDUR"])
            self._trigamp = Counter(Mix([self._firsttrig,self._secondtrig]), min=0, max=2, dir=1)
            self._lfo_amp = LFOSynth(.5, self._trigamp, self._midi_metro)
            self.amp = MidiDelAdsr(self._trigamp, delay=0, attack=.001, decay=.1, sustain=.5, release=1, 
                                mul=self._rawamp*vars.vars["MIDIVELOCITY"], add=self._lfo_amp.sig())
            self.trig = Trig().play()
        elif vars.vars["VIRTUAL"]:
            self._virtualpit = Sig([0.0]*vars.vars["POLY"])
            self._trigamp = Sig([0.0]*vars.vars["POLY"])
            if with_transpo:
                self._transpo = Sig(value=0)
                self.pitch = Snap(self._virtualpit+self._transpo, choice=[0,1,2,3,4,5,6,7,8,9,10,11], scale=scaling)
            else:
                self.pitch = Snap(self._virtualpit, choice=[0,1,2,3,4,5,6,7,8,9,10,11], scale=scaling)
            self._lfo_amp = LFOSynth(.5, self._trigamp, self._midi_metro)
            self.amp = MidiDelAdsr(self._trigamp, delay=0, attack=.001, decay=.1, sustain=.5, release=1, 
                                   mul=self._rawamp, add=self._lfo_amp.sig())
            self.trig = Thresh(self._trigamp)
        else:
            if with_transpo:
                self._note = Notein(poly=vars.vars["POLY"], scale=0)
                self._transpo = Sig(value=0)
                self.pitch = Snap(self._note["pitch"]+self._transpo, choice=[0,1,2,3,4,5,6,7,8,9,10,11], scale=scaling)
            else:
                self._note = Notein(poly=vars.vars["POLY"], scale=scaling)
                self.pitch = self._note["pitch"]
            self._trigamp = self._note["velocity"]
            self._lfo_amp = LFOSynth(.5, self._trigamp, self._midi_metro)
            self.amp = MidiDelAdsr(self._trigamp, delay=0, attack=.001, decay=.1, sustain=.5, release=1, 
                                   mul=self._rawamp, add=self._lfo_amp.sig())
            self.trig = Thresh(self._trigamp)
        
        self._panner = Panner(self, self._trigamp, self._midi_metro)
        self.panL = self._panner.amp_L
        self.panR = self._panner.amp_R
    
        self._params = [self._lfo_amp, None, None, None, self._panner]
        for i, conf in enumerate(config):
            i1 = i + 1
            if conf[0] != "Transposition":
                self._params[i1] = Param(self, i1, conf, self._trigamp, self._midi_metro)
            else:
                self._params[i1] = ParamTranspo(self, self._midi_metro)

    def set(self, which, x):
        self._params[which].set(x)
    
    def __del__(self):
        for param in self._params:
            if param != None:
                del param
        for key in self.__dict__.keys():
            del self.__dict__[key]

class FmSynth(BaseSynth):
    def __init__(self, config):
        BaseSynth.__init__(self, config,  mode=1)
        self.indexLine = self.amp * self.p2
        self.indexrnd = Randi(min=.95, max=1.05, freq=[random.uniform(.5,2) for i in range(4)])
        self.norm_amp = self.amp * 0.1
        self.leftamp = self.norm_amp*self.panL
        self.rightamp = self.norm_amp*self.panR
        self.fm1 = FM(carrier=self.pitch, ratio=self.p1, index=self.indexLine*self.indexrnd[0], mul=self.leftamp)
        self.fm2 = FM(carrier=self.pitch*.997, ratio=self.p1, index=self.indexLine*self.indexrnd[1], mul=self.rightamp)
        self.fm3 = FM(carrier=self.pitch*.995, ratio=self.p1, index=self.indexLine*self.indexrnd[2], mul=self.leftamp)
        self.fm4 = FM(carrier=self.pitch*1.002, ratio=self.p1, index=self.indexLine*self.indexrnd[3], mul=self.rightamp)
        self.mix = Mix([self.fm1.mix(), self.fm2.mix(), self.fm3.mix(), self.fm4.mix()], voices=2)
        self.out = Biquadx(self.mix, freq=self.p3, q=1, type=0, stages=2)

class AddSynth(BaseSynth):
    def __init__(self, config):
        BaseSynth.__init__(self, config, mode=1)
        self.fac = Pow(range(1,6), self.p2, mul=[random.uniform(.995,1.005) for i in range(4)])
        self.feedrnd = Randi(min=.15, max=.25, freq=[random.uniform(.5,2) for i in range(4)])
        self.norm_amp = self.amp * 0.1
        self.leftamp = self.norm_amp*self.panL
        self.rightamp = self.norm_amp*self.panR
        self.sine1 = SineLoop(freq=self.pitch*self.fac[0], feedback=self.p3*self.feedrnd[0], mul=self.leftamp).mix()
        self.sine2 = SineLoop(freq=self.pitch*self.fac[1], feedback=self.p3*self.feedrnd[1], mul=self.rightamp).mix()
        self.sine3 = SineLoop(freq=self.pitch*self.fac[2], feedback=self.p3*self.feedrnd[2], mul=self.leftamp).mix()
        self.sine4 = SineLoop(freq=self.pitch*self.fac[3], feedback=self.p3*self.feedrnd[3], mul=self.rightamp).mix()
        self.out = Mix([self.sine1+self.sine2+self.sine3+self.sine4], voices=2)

class WindSynth(BaseSynth):
    def __init__(self, config):
        BaseSynth.__init__(self, config, mode=1)
        self.clpit = Clip(self.pitch, min=40, max=15000)
        self.norm_amp = self.p3 * .2
        self.leftamp = self.norm_amp*self.panL
        self.rightamp = self.norm_amp*self.panR
        self.noise = Noise(mul=self.amp*self.norm_amp)
        self.dev = Randi(min=0.-self.p2, max=self.p2, freq=self.p1*[random.uniform(.75,1.25) for i in range(4)], add=1)
        self.filt1 = Biquadx(self.noise, freq=self.clpit*self.dev[0], q=self.p3, type=2, stages=2, mul=self.leftamp).mix()
        self.filt2 = Biquadx(self.noise, freq=self.clpit*self.dev[1], q=self.p3, type=2, stages=2, mul=self.rightamp).mix()
        self.filt3 = Biquadx(self.noise, freq=self.clpit*self.dev[2], q=self.p3, type=2, stages=2, mul=self.leftamp).mix()
        self.filt4 = Biquadx(self.noise, freq=self.clpit*self.dev[3], q=self.p3, type=2, stages=2, mul=self.rightamp).mix()
        self.out = Mix([self.filt1, self.filt2, self.filt3, self.filt4], voices=2)

class SquareMod(BaseSynth):
    def __init__(self, config):
        BaseSynth.__init__(self, config, mode=1)
        self.table = SquareTable(order=10, size=2048)
        self.change = Change(self.p1)
        self.trigChange = TrigFunc(self.change, function=self.changeOrder)
        self.lfo = Osc(table=self.table, freq=self.p2, mul=self.p3*.1, add=.1)
        self.norm_amp = self.amp * self.lfo
        self.leftamp = self.norm_amp*self.panL
        self.rightamp = self.norm_amp*self.panR
        self.osc1 = Osc(table=self.table, freq=self.pitch, mul=self.leftamp).mix()
        self.osc2 = Osc(table=self.table, freq=self.pitch*.994, mul=self.rightamp).mix()
        self.osc3 = Osc(table=self.table, freq=self.pitch*.998, mul=self.leftamp).mix()
        self.osc4 = Osc(table=self.table, freq=self.pitch*1.003, mul=self.rightamp).mix()
        self.out = Mix([self.osc1, self.osc2, self.osc3, self.osc4], voices=2)
    
    def changeOrder(self):
        order = int(self.p1.get())
        self.table.order = order

class SawMod(BaseSynth):
    def __init__(self, config):
        BaseSynth.__init__(self, config, mode=1)
        self.table = SawTable(order=10, size=2048)
        self.change = Change(self.p1)
        self.trigChange = TrigFunc(self.change, function=self.changeOrder)
        self.lfo = Osc(table=self.table, freq=self.p2, mul=self.p3*.0707, add=.0707)
        self.norm_amp = self.amp * self.lfo
        self.leftamp = self.norm_amp*self.panL
        self.rightamp = self.norm_amp*self.panR
        self.osc1 = Osc(table=self.table, freq=self.pitch, mul=self.leftamp).mix()
        self.osc2 = Osc(table=self.table, freq=self.pitch*.995, mul=self.rightamp).mix()
        self.osc3 = Osc(table=self.table, freq=self.pitch*.998, mul=self.leftamp).mix()
        self.osc4 = Osc(table=self.table, freq=self.pitch*1.004, mul=self.rightamp).mix()
        self.out = Mix([self.osc1, self.osc2, self.osc3, self.osc4], voices=2)
    
    def changeOrder(self):
        order = int(self.p1.get())
        self.table.order = order

class PulsarSynth(BaseSynth):
    def __init__(self, config):
        BaseSynth.__init__(self, config, mode=1)
        self.table = SawTable(order=10, size=2048)
        self.change = Change(self.p1)
        self.trigChange = TrigFunc(self.change, function=self.changeOrder)
        self.env = HannTable()
        self.lfo = Sine(freq=self.p3, mul=.25, add=.7)
        self.norm_amp = self.amp * 0.2
        self.leftamp = self.norm_amp*self.panL
        self.rightamp = self.norm_amp*self.panR
        self.pulse1 = Pulsar(table=self.table, env=self.env, freq=self.pitch, frac=self.lfo, mul=self.leftamp).mix()
        self.pulse2 = Pulsar(table=self.table, env=self.env, freq=self.pitch*.998, frac=self.lfo, mul=self.rightamp).mix()
        self.pulse3 = Pulsar(table=self.table, env=self.env, freq=self.pitch*.997, frac=self.lfo, mul=self.leftamp).mix()
        self.pulse4 = Pulsar(table=self.table, env=self.env, freq=self.pitch*1.002, frac=self.lfo, mul=self.rightamp).mix()
        self.out = Mix([self.pulse1, self.pulse2, self.pulse3, self.pulse4], voices=2)
    
    def changeOrder(self):
        order = int(self.p1.get())
        self.table.order = order

class Ross(BaseSynth):
    def __init__(self, config):
        BaseSynth.__init__(self, config, mode=1)
        self.rosspit = Clip(self.pitch / 5000. + 0.25, min=0., max=1.)
        self.deviation = Randi(min=0.-self.p2, max=self.p2, freq=[random.uniform(2,4) for i in range(2)], add=1)
        self.norm_amp = self.amp * 0.3
        self.leftamp = self.norm_amp*self.panL
        self.rightamp = self.norm_amp*self.panR
        self.ross1 = Rossler(pitch=self.rosspit*self.deviation[0], chaos=self.p1, stereo=True, mul=self.leftamp).mix()
        self.ross2 = Rossler(pitch=self.rosspit*self.deviation[1], chaos=self.p1, stereo=True, mul=self.rightamp).mix()
        self.mix = Mix([self.ross1, self.ross2], voices=2)
        self.eq = EQ(self.mix, freq=260, q=25, boost=-12)
        self.out = Biquad(self.eq, freq=self.p3)

class Wave(BaseSynth):
    def __init__(self, config):
        BaseSynth.__init__(self, config, mode=1)
        self.change = Change(self.p1)
        self.trigChange = TrigFunc(self.change, function=self.changeWave)
        self.norm_amp = self.amp * 0.15
        self.leftamp = self.norm_amp*self.panL
        self.rightamp = self.norm_amp*self.panR
        self.wav1 = LFO(freq=self.pitch, sharp=self.p3, type=0, mul=self.leftamp)
        self.wav2 = LFO(freq=self.pitch*.997, sharp=self.p3, type=0, mul=self.rightamp)
        self.wav3 = LFO(freq=self.pitch*1.002, sharp=self.p3, type=0, mul=self.leftamp)
        self.wav4 = LFO(freq=self.pitch*1.0045, sharp=self.p3, type=0, mul=self.rightamp)
        self.out = Mix([self.wav1.mix(),self.wav2.mix(),self.wav3.mix(),self.wav4.mix()], voices=2)
    
    def changeWave(self):
        typ = int(self.p1.get())
        self.wav1.type = typ
        self.wav2.type = typ
        self.wav3.type = typ
        self.wav4.type = typ

class PluckedString(BaseSynth):
    def __init__(self, config):
        BaseSynth.__init__(self, config, mode=1)
        self.deviation = Randi(min=0.-self.p3, max=self.p3, freq=[random.uniform(2,4) for i in range(2)], add=1)
        self.table = CosTable([(0,0),(50,1),(300,0),(8191,0)])
        self.impulse = TrigEnv(self.trig, table=self.table, dur=.1)
        self.noise = Biquad(Noise(self.impulse), freq=2500)
        self.leftamp = self.amp*self.panL
        self.rightamp = self.amp*self.panR
        self.wave1 = Waveguide(self.noise, freq=self.pitch*self.deviation[0], dur=self.p2, minfreq=.5, mul=self.leftamp).mix()
        self.wave2 = Waveguide(self.noise, freq=self.pitch*self.deviation[1], dur=self.p2, minfreq=.5, mul=self.rightamp).mix()
        self.out = Mix([self.wave1, self.wave2], voices=2)

class Reson(BaseSynth):
    def __init__(self, config):
        BaseSynth.__init__(self, config, mode=1)
        self.deviation = Randi(min=0.-self.p2, max=self.p2, freq=[random.uniform(2,4) for i in range(4)], add=1)
        self.excite = Noise(.02)
        self.leftamp = self.amp*self.panL
        self.rightamp = self.amp*self.panR
        self.wave1 = Waveguide(self.excite, freq=self.pitch*self.deviation[0], dur=30, minfreq=1, mul=self.leftamp).mix()
        self.wave2 = Waveguide(self.excite, freq=self.pitch*self.deviation[1], dur=30, minfreq=1, mul=self.rightamp).mix()
        self.mix = Mix([self.wave1, self.wave2], voices=2)
        self.out = Biquad(self.mix, freq=self.p3)

def checkForCustomModules():
    path = ""
    preffile = os.path.join(os.path.expanduser("~"), ".zynerc")
    if os.path.isfile(preffile):
        with codecs.open(preffile, "r", encoding="utf-8") as f:
            lines = f.readlines()
            if not lines[0].startswith("### Zyne") or not vars.constants["VERSION"] in lines[0]:
                pass
            else:
                for line in lines:
                    if "CUSTOM_MODULES_PATH" in line:
                        line = line.strip()
                        if line:
                            sline = line.split("=")
                            path = vars.vars["ensureNFD"](sline[1].strip())
    
    if path != "":
        if os.path.isfile(path):
            execfile(vars.vars["toSysEncoding"](path), globals())
            vars.vars["EXTERNAL_MODULES"] = MODULES

checkForCustomModules()
