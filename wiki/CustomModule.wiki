#summary Tutorial on how to create a custom Zyne module.

=Welcome to the tutorial on how to create a custom zyne module.=
 
==1. Sections==

  # Sections
  # Introduction
  # API
  # Basics
  # Reserved variables
  # Examples
  #  Generic class to use as a startup

==2. Introduction== 

What must be defined to include custom modules in the zyne application ?

- In a python file:
  * Classes implementing custom dsp chains.
  * A dictionary, called `MODULES`, specifying the modules and their properties.
- In the preferences panel:
  * The path to your python file. Several modules can be defined in the file.


==3. API==

{{{
class BaseSynth(self, config, mode=1)
}}}

Parameters :
    config : dict
        This is the user-defined configuration dictionnary automatically sent by the application
        to the module in order to properly initialize the module. It must be passed directly from
        the module's __init__ method to the BaseSynth's __init__ method.
    mode : int {1, 2, 3}, optional
        mode=1 (default) means that the pitches from the keyboard are directly converted in Hertz.
        mode=2 means that the pitches from the keyboard are converted into transposition factor 
        with the Midi key 60 as 1.0, eg. no transposition.
        mode=3 means that the pitches from the keyboard keep their Midi note value.
        
        The keyboard can be transposed in semitones before the midi-to-hertz or the
        midi-to-transpo conversion. This is automatically done when a slider is 
        defined with "Transposition" as the param_name.

Attributes :
    self.pitch : this variable contains frequencies, in Hertz, Midi notes or transposition factors, from the pitches played on keyboard.
    self.amp : this variable contains the ADSR amplitude envelope, normalized between 0 and 1, derived from the velocities played on the keyboard.
    self.trig : this variable contains trigger streams generated by the noteon played on the keyboard. Useful to trig an envelope or a sound at the beginning of a note.
    self.p1, self.p2, self.p3 : user-defined slider's values.

{{{
MODULES = {module_name : {  "title" : title_to_be_displayed,
                            "synth" : ref_to_custom_class,
                            "p1" : [param_name, init, min, max, is_integer, is_log],
                            "p2" : [param_name, init, min, max, is_integer, is_log],
                            "p3" : [param_name, init, min, max, is_integer, is_log]
                          },
          }
}}}

All custom module's properties are defined in a dictionary of dictionaries called "MODULES", one 
dictionary per module.

Syntax:
    module_name : str
        Reference name of the module, as it will appear in the Modules menu. Value for this key
        is the dictionary of properties for the module.
    title_to_be_displayed : str
        String that will appear at the top of the module panel.
    ref_to_custom_class : class derived from BaseSynth
        Reference to the class implementing the dsp chain.
    param_name : str
        Label of the slider for the parameter. If "Transposition" is used as the param_name, the 
        slider will be automatically used to transpose the note before the the midi-to-hertz or the 
        midi-to-transpo conversion. The slider's properties (init, min, max, is_int) must be integer.
    init : int or float
        Initial value of the slider.
    min : int or float
        Minimum value of the slider.
    max : int or float
        Maximum value of the slider.
    is_integer : boolean
        Set this value to True to create a slider of integers or False to create a slider of floats.
    is_log : boolean
        Set this value to True to create a logarithmic slider (`min` must be non-zero) or False to 
        create a linear slider.


==4. Basics== 

Each module must be derived from the class "BaseSynth" (you don't need to import specific modules
since your file will be executed in the proper environment).

The "BaseSynth" class is where are handled "pitch", "amplitude", "polyphony", user-defined attributes
(p1, p2, p3) and samples exportation.

Initialisation of the class BaseSynth:

{{{
BaseSynth.__init__(self, config, mode)
}}}

So your custom class should be defined like this:

{{{
class MySound(BaseSynth):
    def __init__(self, config):
        BaseSynth.__init__(self, config, mode=1)
}}}

==5. Reserved variables== 

self.pitch : this variable contains frequencies, in Hertz, Midi notes or transposition factors, 
            from the pitches played on keyboard.
self.amp : this variable contains the ADSR amplitude envelope, normalized between 0 and 1, derived
            from the velocities played on the keyboard.
self.trig : this variable contains trigger streams generated by the noteon played on the keyboard.
            Useful to trig an envelope or a sound at the beginning of the note.
self.p1, self.p2, self.p3 : user-defined slider's values.
self.out : This variable must be the object that send the sound to the output. Although it is 
            possible, the custom class should not called the `out` method of any object. Every signals
            must be mixed in the self.out variable, which will then be sent to the post-processing
            effects and finally to the soundcard.

To minimise conflicts between variable's names, all other variables used in the class "BaseSynth" 
begin with an underscore. If you don't use this syntax in your custom classes, you will avoid to
override basic module's objects.


==6. Examples==

Example of a file containing two modules. First, a simple module implementing a chorus of sine waves 
using semitone transposition and second, a soundfile looper/slicer using transposition factor derived 
from the keyboard's pitches.

{{{
class ChoruSyn(BaseSynth):
    def __init__(self, config):
        BaseSynth.__init__(self, config, mode=1)
        # First slider is used as semitone transpo, so self.p1 is not defined
        # self.p2 = "Deviation speed"
        # self.p3 = "Deviation range"
        # 6 interpolated randoms
        self.pitchVar = Randi(min=0.-self.p3, max=self.p3, 
                              freq=self.p2*[random.uniform(.95, 1.05) for i in range(6)], add=1)
        # 6 oscillators (separated to properly handle keyboard polyphony)
        self.norm_amp = self.amp * .1
        self.osc1 = Sine(freq=self.pitch*self.pitchVar[0], mul=self.norm_amp).mix(1)
        self.osc2 = Sine(freq=self.pitch*self.pitchVar[1], mul=self.norm_amp).mix(1)
        self.osc3 = Sine(freq=self.pitch*self.pitchVar[2], mul=self.norm_amp).mix(1)
        self.osc4 = Sine(freq=self.pitch*self.pitchVar[3], mul=self.norm_amp).mix(1)
        self.osc5 = Sine(freq=self.pitch*self.pitchVar[4], mul=self.norm_amp).mix(1)
        self.osc6 = Sine(freq=self.pitch*self.pitchVar[5], mul=self.norm_amp).mix(1)
        # stereo mix of all oscillators
        self.out = Mix([self.osc1, self.osc2, self.osc3, self.osc4, self.osc5, self.osc6], voices=2).out()

class SndLooper(BaseSynth):
    def __init__(self, config):
        BaseSynth.__init__(self, config, mode=2)
        self.table = SndTable(SNDS_PATH+"/transparent.aif")
        self.st = Phasor(.1, mul=self.table.getDur()-.25)
        self.dur = Choice([.125, .125, .125, .25, .25, .5], freq=1)
        self.varFreq = self.p2*[random.uniform(.95, 1.05) for i in range(2)]
        self.pitchVar = Randi(min=0.-self.p3, max=self.p3, freq=self.varFreq, add=1)
        self.looper1 = Looper(self.table, pitch=self.pitch, start=self.st*self.pitchVar[0], 
                          dur=self.dur, interp=4, autosmooth=True, mul=self.amp).mix(1)
        self.looper2 = Looper(self.table, pitch=self.pitch, start=self.st*self.pitchVar[1], 
                          dur=self.dur, interp=4, autosmooth=True, mul=self.amp).mix(1)
        self.out = Mix([self.looper1, self.looper2], voices=2)

MODULES = {
            "ChoruSyn": { "title": "--- Chorused sines ---", "synth": ChoruSyn, 
                    "p1": ["Transposition", 0, -36, 36, True, False],
                    "p2": ["Deviation speed", 1, .1, 10, False, False],
                    "p3": ["Deviation range", 0.02, 0.001, .5, False, True]
                    },
            "SndLooper": { "title": "--- Sound Looper ---", "synth": SndLooper, 
                    "p1": ["Transposition", 0, -36, 36, True, False],
                    "p2": ["Deviation speed", 1, .1, 10, False, False],
                    "p3": ["Deviation range", 0.02, 0.001, .5, False, True]
                    },
          }
}}}

==7. Generic class to use as a startup== 

{{{
class GenericModule(BaseSynth):
    def __init__(self, config):
        # `mode` handles pitch conversion : 1 for hertz, 2 for transpo, 3 for midi
        BaseSynth.__init__(self, config, mode=1)
        self.fm1 = FM(carrier=self.pitch, ratio=self.p1, index=self.p2, mul=self.amp).mix(1)
        self.fm2 = FM(carrier=self.pitch*0.997, ratio=self.p1, index=self.p2, mul=self.amp).mix(1)
        self.mix = Mix([self.fm1, self.fm2], voices=2)
        self.out = Biquad(self.mix, freq=self.p3, q=1, type=0)

MODULES = {
            "GenericModule": { "title": "--- Generic module ---", "synth": GenericModule, 
                    "p1": ["Ratio", 0.5, 0, 10, False, False],
                    "p2": ["Index", 5, 0, 20, False, False],
                    "p3": ["LP cutoff", 4000, 100, 15000, False, True]
                    },
          }
}}}